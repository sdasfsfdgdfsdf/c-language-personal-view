"abc"是常量吗？答案是有时是，有时不是。
不是常量的情况："abc"作为字符数组初始值的时候就不是，如     char str[] = "abc"; 因为定义的是一个字符数组，所以就相当于定义了一些空间来存放"abc"，而又因为字符数组就是把字符一个一个地存放的，所以编译器把这个语句解析为    char str[3] = { 'a','b','c' }; 又根据上面的总结1，所以 char str[] = "abc"; 的最终结果是 char str[4] = { 'a','b','c','\0' }; 做一下扩展，如果char str[] = "abc"; 是在函数内部写的话，那么这里 的"abc\0"因为不是常量，所以应该被放在栈上。

是常量的情况： 把"abc"赋给一个字符指针变量时，如     char* ptr = "abc";   因为定义的是一个普通指针，并没有定义空间来存放"abc"，所以编译器得帮我们找地方来放"abc"，显然，把这里的"abc"当成常量并把它放到程序 的常量区是编译器 最合适的选择。所以尽管ptr的类型不是const char* ，并且ptr[0] = 'x'; 也能编译 通过，但是执行ptr[0] = 'x'; 就会发生运行时异常，因为这个语句试图去修改程序 常量区中的东西。记得哪本书中曾经说过char* ptr = "abc"; 这种写法原来在c++标准中是不允许的， 但是因为这种写法在c中实在是太多了，为了兼容c，不允许也得允许。虽然允许， 但是建议的写法应该是const char* ptr = "abc"; 这样如果后面写ptr[0] = 'x'的话编译器就不会让它编译通过，也就避免了上面说的运行时异常。    又扩展一下，如果char * ptr = "abc"; 写在函数体内，那么虽然这里的"abc\0"被放在常量区中，但是ptr本身只是一个普通的指针变量，所以ptr是被放在栈上的， 只不过是它所指向的东西被放在常量区罢了
我真是个傻逼,源文件打不开,我以为电脑问题,没想到"test.c"给我先写成了<test.c>
 最终在项目 -》 属性 -》 C/C++ -》常规 中的使用Windows运行时扩展，选择是就解决了这个问题
 下载windows10 SDK(10.017763.0)补丁包
 自己想出来的，既然无法打开源文件，可能是找不到文件路径。那么我把头文件的绝对地址加上，果不其然无法打开有源文件的问题解决了。
 点击项目-》属性-》VC++目录-》包含目录,点击编辑 包含该头文件的目录如下，需要注意的是从visual studio上游览时是看不到文件的，进入此文件夹，然后点击“选择文件”夹即可。将刚才自己写的头文件的地址包含进来，点击确定就解决了。
 文件打不开的三种解决方法
 报错：

在创建项目时由于勾选了“把解决方案和项目放在同一目录中”中导致打开项目存放路径时无法找到项目中的.cpp文件和.h文件

此外，还导致了“头文件”文件夹中“#include * *.h文件”显示“无法打开源文件”

按照参考链接的第一个方法，怀疑是由于勾选问题

于是把原项目中的.cpp文件和.h文件的内容全部复制粘贴到另一个编译器上，退出项目，重新创建新项目，注意确保没有勾选“把解决方案和项目放在同一目录中”，再复制粘贴回来，发现没有再报错

 ile文件是cpp文件的时候报错原因：因为main.cpp文件包含了file.cpp文件，所以fun函数在file.cpp文件中编译了一次，又在main.cpp文件中编译了一次。在第二次编译时，因为已经存在同名函数，所以报错。

file文件是c文件的时候不报错的原因：c文件编译函数不会对函数进行name mandling（名称修饰），cpp文件在编译函数会对函数进行name mandling（C++支持函数重载）。此时fun函数同样会编译两次，但是不会有重命名的情况。

拓展：当为下面这种情况时，file文件是c文件仍会报错，原因是因为f.cpp文件和main.cpp文件同时包含了file.c文件，此时fun函数会编译三次，在f.cpp和mian.cpp文件中编译的fun函数会重名，所以报错
